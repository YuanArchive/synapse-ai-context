import os
from pathlib import Path
from typing import Dict, Any, List, Set
import networkx as nx


class MarkdownGenerator:
    """
    Generates a detailed SYNAPSE.md file for a project,
    summarizing its structure, symbols, and dependencies for AI agents.
    """

    def __init__(
        self, project_path: Path, analysis_summary: Dict[str, Any], graph: nx.DiGraph
    ):
        self.project_path = project_path
        self.summary = analysis_summary
        self.graph = graph

    def generate(self) -> str:
        content = []
        content.append(f"# ğŸŒªï¸ Synapse Project Intelligence: {self.project_path.name}\n")
        content.append(
            "This project is indexed by **Synapse**. This document provides a high-level architectural map for AI agents to ensure context awareness and reliable code manipulation.\n"
        )

        content.append("## ğŸ“Š Analysis Summary")
        content.append(f"- **Files Analyzed**: {self.summary.get('files_analyzed')}")
        content.append(
            f"- **Global Symbols**: {len([n for n, d in self.graph.nodes(data=True) if d.get('type') == 'symbol'])}"
        )
        content.append(
            f"- **Relationship Density**: {self.summary.get('graph_edges')} edges / {self.summary.get('graph_nodes')} nodes\n"
        )

        content.append("## ğŸ—ºï¸ Architecture Map")
        content.append("High-level dependency flow (Mermaid):\n")
        content.append("```mermaid")
        content.append(self._generate_mermaid_graph())
        content.append("```\n")

        content.append("## ğŸ—ï¸ Project Structure")
        files = [n for n, d in self.graph.nodes(data=True) if d.get("type") == "file"]
        tree = self._build_tree(files)
        content.append("```text")
        content.append(self._format_tree(tree))
        content.append("```\n")

        content.append("## ğŸ§  Core Intelligence Matrix")
        content.append(
            "Detailed analysis of key project components and their relationships.\n"
        )

        # Sort files by connectivity (importance)
        sorted_files = sorted(files, key=lambda x: self.graph.degree(x), reverse=True)

        for f in sorted_files:
            rel_path = os.path.relpath(f, self.project_path)
            # Skip some noise if needed, but let's show all for now

            content.append(f"### ğŸ“„ `{rel_path}`")

            # 1. Definitions (defines)
            definitions = []
            for neighbor in self.graph.successors(f):
                edge_data = self.graph.get_edge_data(f, neighbor)
                if edge_data.get("type") == "defines":
                    symbol_name = self.graph.nodes[neighbor].get("name", neighbor)
                    definitions.append(f"`{symbol_name}`")

            if definitions:
                content.append(f"- **Definitions**: {', '.join(definitions)}")

            # 2. Dependencies (calls)
            dependencies = set()
            for neighbor in self.graph.successors(f):
                edge_data = self.graph.get_edge_data(f, neighbor)
                if edge_data.get("type") == "calls":
                    symbol = edge_data.get("symbol", "?")
                    target_rel = os.path.relpath(neighbor, self.project_path)
                    dependencies.add(f"`{symbol}` in `{target_rel}`")

            if dependencies:
                content.append("- **Dependencies**:")
                for dep in sorted(list(dependencies)):
                    content.append(f"  - Calls {dep}")

            # 3. Dependents (called by)
            dependents = set()
            for neighbor in self.graph.predecessors(f):
                edge_data = self.graph.get_edge_data(neighbor, f)
                if edge_data.get("type") == "calls":
                    symbol = edge_data.get("symbol", "?")
                    caller_rel = os.path.relpath(neighbor, self.project_path)
                    dependents.add(f"`{caller_rel}` (via `{symbol}`)")

            if dependents:
                content.append("- **Dependents**:")
                for dep in sorted(list(dependents)):
                    content.append(f"  - Referenced by {dep}")

            content.append("")

        content.append("## âš¡ï¸ AI Agent Protocols")
        content.append(
            '1. **Verify Context**: Run `synapse search "<query>"` to locate logic before modification.'
        )
        content.append(
            "2. **Impact Analysis**: Check the **Dependents** section above before changing function signatures."
        )
        content.append(
            "3. **Structured Response**: Prefer creating `Artifacts` for complex architectural changes."
        )
        content.append(
            "4. **Deep Reasoning**: Use `--think` or `--deep-think` flags for non-trivial refactors.\n"
        )

        content.append("---\n*Generated by Synapse v0.1.0*")

        return "\n".join(content)

    def _generate_mermaid_graph(self) -> str:
        """Generates a structured Mermaid graph with subgraphs."""
        lines = ["graph TD"]
        lines.append("    %% Styles")
        lines.append("    classDef cluster fill:#f9f9f9,stroke:#333,stroke-width:2px;")
        lines.append(
            "    classDef file fill:#ffffff,stroke:#333,stroke-width:1px,rx:5,ry:5;"
        )
        lines.append(
            "    classDef external fill:#eee,stroke:#999,stroke-dasharray: 5 5;"
        )

        # Filter for file nodes
        files = [n for n, d in self.graph.nodes(data=True) if d.get("type") == "file"]

        # Map file paths to IDs
        file_to_id = {f: f"F{i}" for i, f in enumerate(files)}

        # Build hierarchy
        tree = self._build_tree_with_ids(files, file_to_id)

        # Generate nodes with subgraphs
        self._render_subgraphs(tree, lines, indent="    ")

        # Add Edges
        edge_count = 0
        max_edges = 150  # Increased limit for better context

        # Prioritize edges between different directories (architectural significance)
        edges = []
        for u, v, data in self.graph.edges(data=True):
            if u in file_to_id and v in file_to_id:
                if data.get("type") == "calls":
                    edges.append((u, v))

        # Sort edges: cross-module first? Or just simple sort.
        # Let's just limit for now.
        for u, v in edges:
            if edge_count >= max_edges:
                break

            uid = file_to_id[u]
            vid = file_to_id[v]

            # Avoid self-loops in visualization if any
            if uid != vid:
                lines.append(f"    {uid} --> {vid}")
                edge_count += 1

        if edge_count == 0:
            lines.append(
                "    style F0 stroke:#333,stroke-width:2px; %% No dependencies found"
            )

        return "\n".join(lines)

    def _build_tree_with_ids(
        self, files: List[str], file_to_id: Dict[str, str]
    ) -> Dict:
        tree = {}
        for f in files:
            try:
                try:
                    rel_path = os.path.relpath(f, self.project_path)
                except ValueError:
                    rel_path = f

                parts = rel_path.split(os.sep)
                current = tree
                for i, part in enumerate(parts):
                    if i == len(parts) - 1:
                        # Leaf node (File)
                        current[part] = {"__id__": file_to_id[f], "__path__": f}
                    else:
                        # Directory
                        if part not in current:
                            current[part] = {}
                        current = current[part]
            except Exception:
                continue
        return tree

    def _render_subgraphs(self, tree: Dict, lines: List[str], indent: str):
        for key, value in sorted(tree.items()):
            if isinstance(value, dict) and "__id__" in value:
                # It's a file
                node_id = value["__id__"]
                safe_name = key.replace('"', "'")
                lines.append(f'{indent}{node_id}["{safe_name}"]:::file')
            else:
                # It's a directory (subgraph)
                # Skip top-level if it's just one folder like "."
                subgraph_id = f"cluster_{key.replace('.', '_').replace('-', '_')}_{hash(key) % 1000}"
                lines.append(f"{indent}subgraph {subgraph_id} [{key}]")
                # Recursive call
                self._render_subgraphs(value, lines, indent + "    ")
                lines.append(f"{indent}end")

    def _build_tree(self, files: List[str]) -> Dict:
        tree = {}
        for f in files:
            try:
                # Handle cases where path might be outside or absolute
                try:
                    rel_path = os.path.relpath(f, self.project_path)
                except ValueError:
                    rel_path = f

                parts = rel_path.split(os.sep)
                current = tree
                for part in parts:
                    if part not in current:
                        current[part] = {}
                    current = current[part]
            except Exception:
                continue
        return tree

    def _format_tree(self, tree: Dict, indent: str = "") -> str:
        lines = []
        keys = sorted(tree.keys())
        for i, key in enumerate(keys):
            is_last = i == len(keys) - 1
            prefix = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
            lines.append(f"{indent}{prefix}{key}")

            new_indent = indent + ("    " if is_last else "â”‚   ")
            child_lines = self._format_tree(tree[key], new_indent)
            if child_lines:
                lines.append(child_lines)
        return "\n".join(lines)
